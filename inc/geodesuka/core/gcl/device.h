#pragma once
#ifndef GEODESUKA_CORE_GCL_DEVICE_H
#define GEODESUKA_CORE_GCL_DEVICE_H

#include "../math/number/type.h"

#include "config.h"

namespace geodesuka {
	class engine;
}

namespace geodesuka::core::object {
	class system_display;
}

namespace geodesuka::core::gcl {

	class device {
	public:

		friend class engine;
		friend class context;

		// Queue Family Support Options
		enum qfs {
			TRANSFER				= 0x00000001,
			COMPUTE					= 0x00000002,
			GRAPHICS				= 0x00000004,
			GRAPHICS_AND_COMPUTE	= GRAPHICS | COMPUTE,
			PRESENT					= 0x00000008
		};

		enum memory {
			DEVICE_LOCAL			= 0x00000001,
			HOST_VISIBLE			= 0x00000002,
			HOST_COHERENT			= 0x00000004,
			HOST_CACHED				= 0x00000008,
			LAZILY_ALLOCATED		= 0x00000010,
			PROTECTED				= 0x00000020
		};
		
		struct queue_family_capability {
			// Supported Operations
			vk_queue_flags Flags;
			bool isTransferSupported;
			bool isComputeSupported;
			bool isGraphicsSupported;
			bool isPresentSupported;
			uint Support;
		};

		// Managed by engine, should be generated by engine.
		// TODO: Pass engine instance into argument?
		device(vk_instance aInstance, vk_physical_device aPhysicalDevice);
		~device();

		// User can provide a list of extensions to this method to check if they are all
		// supported. Will return true if provided list of extensions is supported. Will
		// return false if at least one extension is not supported.
		bool is_extension_list_supported(uint32_t aExtensionCount, const char** aExtensionList) const;

		// ----- Query ----- //

		vk_physical_device_properties get_properties() const;
		vk_physical_device_features get_features() const;
		vk_physical_device_memory_properties get_memory_properties() const;
		const vk_extension_properties* get_extensions(uint32_t* aExtensionCount) const;

		// ----- Memory Allocation Utils ----- //

		int get_memory_property_flags_index(vk_memory_requirements aMemoryRequirements, vk_memory_property_flags aMemoryPropertyFlags) const;
		vk_memory_property_flags get_memory_property_flags(int aMemoryPropertyFlagsIndex);

		const vk_queue_family_properties* get_queue_family_properties(uint32_t* aQueueFamilyCount) const;
		const queue_family_capability* get_capability(uint32_t* aQueueFamilyCount) const;

		// Checks if device has a queue that supports desired operations.
		bool available(unsigned int aQFS) const;

		// Input desired operations, and returns family index of a Queue that supports the desired operations
		// with minimum extraneous options. If the desired operations are not supported by the device, the 
		// function will return -1.
		int qfi(unsigned int aQFS) const;

		// ----- Handles ----- //

		vk_instance inst();
		vk_physical_device handle();

	private:

		//std::vector<object::system_display*> ChildDisplay;

		vk_instance ParentInstance;
		vk_physical_device Handle;

		uint32_t QueueFamilyCount;
		vk_queue_family_properties* QueueFamilyProperty;
		queue_family_capability* QueueFamilyCapability;
		uint32_t* QueueFamilySupportCount;

		// Properties, Features, and Extensions Available.
		uint32_t ExtensionCount;
		vk_extension_properties* Extension;
		vk_physical_device_properties Properties{};
		vk_physical_device_features Features{};
		vk_physical_device_memory_properties MemoryProperties{};

	};

}

#endif // !GEODESUKA_CORE_GCL_DEVICE_H
